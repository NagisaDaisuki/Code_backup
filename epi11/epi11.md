# ♿ 动态内存分配

- 数组的元素存储于内存中连续的位置上。当一个数组被声明时，它所需要的内存在**编译时**就被分配。但是也可以使用动态内存分配在**运行时**为它分配内存。

## 11.1 为什么使用动态内存分配

如果是已经知道数量大小的数组分配发生在编译时，但如果在编译时不能确定数组长度(数组的长度常常在运行时才知道)，因为所需内存空间取决于输入数据。

## 11.2 malloc和free

- `malloc`执行动态内存分配`free`执行分配内存的释放。这些函数维护一个可用内存池。
- `malloc`分配的动态内存没有初始化，可以使用`calloc`函数初始化也可以手动初始化。

函数原型(在`stdlib.h`中声明)

~~~C
void *malloc(size_t size);
void *free(void *pointer);
~~~

`malloc`分配的是一块连续的内存，如果请求分配100字节的内存那么实际分配的内存就是100个连续的字节。
> `malloc`分配的内存可能比请求的内存大小稍微多一点，这个行为是由编译器定义的。

内存池如果是空的(可用内存无法满足请求)`malloc`函数会像操作系统请求得到更多的内存。并在这块新的内存上执行分配任务。如果操作系统无法向malloc提供更多的内存，malloc就返回一个NULL指针。***因此对malloc所分配的内存确保其是非空(NULL)是非常重要的***。

~~~C
int *a_pointer = (int*)malloc(sizeof(int) * 100);
if (a_pointer == NULL)
  return -1; // 在函数内提前退出并返回错误值-1
~~~

`free`的参数只能是`NULL`或是之前请求分配内存函数`malloc`,`calloc`或`realloc`的返回值。向`free`函数传递一个NULL参数没有任何意义。
> 因为malloc的返回值是一个`void*`类型，在比较老的编译器(C89或之前)可能会要求对返回值进行强制类型转换(int*)。

> 二次释放和悬空指针：对同一块内存调用两次`free(ptr)`会导致堆损坏和程序崩溃；`free(ptr)`后`ptr`仍然指向已释放的内存。为了安全应立即执行`ptr=NULL`将指针置为空指针，避免后续误用。

## 11.3 calloc和realloc

函数原型(在`stdlib.h`中声明)

~~~C
void *calloc(size_t num_elements, size_t element_size);
void *realloc(void *ptr,size_t new_size);
~~~

`calloc`也用于分配内存，而`realloc`用于修改一个原先已经分配的内存块大小，使用`realloc`可以扩大和缩小内存大小。

> `malloc`分配的内存是未初始化的，内容是随机的垃圾值；`calloc`分配的内存会被初始化为全0。  
> `realloc`重新分配内存大小失败时会返回NULL但原始指针ptr指向的内存块仍有效，数据保持不变。

> realloc(NULL,size) == malloc(size)  
> realloc(ptr,0) == free(ptr)并返回NULL

## 11.4 使用动态分配的内存

~~~C
int *pi;
...
pi = malloc(100); // 如果分配成功，在整型为 4 个字节大小的机器上被当作25个整型元素的数组
pi = malloc(25 * sizeof(int)); // 这种分配方式更好一些因为它是可移植的
...
// 使用内存：为内存分配元素
int *pi2, i;

pi2 = pi;
for(;pi2 != pi + 25;)
  *pi2++ = 0;

// 使用下标
for(i = 0; i < 25; i++)
  pi[i] = 0;
~~~

## 11.5 常见的动态内存错误

- 释放内存的一部分是不允许的，动态分配的内存必须一起释放。可以使用`realloc`函数缩小一块动态分配的内存并有效地释放尾部的部分内存(还是用原分配函数的返回值)

~~~C
pi = malloc(10 * sizeof(int));
free(pi + 5); // 释放部分内存
~~~

**内存泄露**

分配内存但在使用完毕后不释放将引起内存泄露(memory leak)。在那些所有执行程序共享一个通用内存池的操作系统中，内存泄露将一点点地榨干可用内存。

其他操作系统能够记住每个程序当前拥有的内存段，这样当一个程序终止时，所有分配给它但未被释放的内存都归还给内存池。

# 🖐 数组

## 8.1 一维数组

- **指针与数组并不是相等的。**

### 8.1.1 数组名

考虑下面的这些声明:

~~~shell
int a;
int b[10];
~~~

> a为标量，因为它是一个单一的值；b为数组，因为它是一些值的集合。

**数组**: 相同类型的值的集合。

> int b[10]中的b并不表示整个数组而是表示数组首个元素的地址。数组为`int`类型表示数组名的类型为"指向int的常量指针"。

- 区分指针与数组差别的其中一个理由是数组名是**指针常量**而不是**指针变量**。

> 常量的值是不能修改的，这也就意味着如果有一个指针`int *c`那么b = c这种赋值是非法的，因为b是常量。

### 8.1.2 下标引用

- **除优先级外，下标引用和间接访问完全相同。**

~~~shell
array[subscript] == *(array + (subscript))
~~~

**证明相等性:**

~~~shell
int array[10];
int *ap = array + 2;
~~~

|statement|expression|
|:----:|:---:|
|ap|array + 2 and &array[2]|
|*ap|array[2] and *(array + 2)|
|ap[0]|*(ap + 0) and array[2]|
|ap+6|array + 8 and &array[8]|
|*ap+6|array[2] + 6|
|*(ap+6)|array[8]|
|ap[6]|*(ap+6)|
|&ap|**unpredictable**|
|ap[-1]|**correct operation and its array[1]**|
|ap[9]|**unpredictable**|

> **偏移量的负数是可以允许的**

最后两个例子显示了为什么**下标检查**在C中是一项困难的任务。最初的C编译器并不检查下标，而最新的编译器有些依然不检查下标。且如果编译器进行下标检查涉及的开销比想象的多。

> 2[array] 是一个**合法**的数组表示！它表示的是 *(2 + array)，也就是*(array + 2)即array[2]。

### 8.1.3 指针与下标

- 如果可以互换地使用指针表达式和下标表达式，下标绝不会比指针更有效率，指针表达式有时候比下标表达式**更有效率**。

**下标方案执行循环**

~~~shell
int array[10],a;
for (a = 0;a < 10;a++)
  array[a] = 0;
~~~

**指针间接访问方案执行循环**

~~~shell
int array[10],*ap;
for (ap = array;ap < array + 10;ap++)
  *ap = 0;
~~~

- 在比较老的编译器中指针间接访问比下标访问更有效率  

**1. 数组下标版本**  
对于`array[a] = 0;`这行代码，计算机在每次循环时都必须做以下三件事：  
a. 找到数组的起始地址(`array`);  
b. 将循环变量`a`乘以`int`类型的大小(例如四字节)；  
c. 将相乘的结果**加到**起始地址，才能找到`array[a]`的准确内存位置。

> 这个过程在每次循环中都涉及**一次乘法和一次加法**。

**2. 指针间接访问版本**  
对于`*ap = 0;`这行代码，计算机的处理方法更直接：  
a. 指针`ap`已经直接存储了当前要操作的内存地址。  
b. `*ap`操作直接访问地址，非常快。  
c. `ap++`操作只需要简单地在`ap`的地址上加上`int`类型的大小(例如四字节)，就能得到下一个元素的地址。

> 这个过程只涉及**一次简单的加法**，比乘法要快得多。

- 但现代编译器**非常智能**，像数组下标版本会被**优化成更高效的指针算术指令**。

### 8.1.4 指针的效率

- 程序的效率取决于你的**编译器**和**机器**。

把一个数组的内容复制到另一个数组：

~~~shell
#define SIZE 50
int x[SIZE];
int y[SIZE];
int i;
int *p1,*p2;
~~~

下标版本函数：

~~~shell
void try1()
{
  for(i = 0; i < SIZE;i++)
    x[i] = y[i];
}
~~~

指针版本函数：

~~~shell
void try2()
{
    for( p1 = x, p2 = y; p1 - x < SIZE;)
      *p1++ = *p2++;
}
~~~

重新使用计数器：

~~~shell
void try3()
{
  for( i = 0; p1 = x, p2 = y; i < SIZE; i++)
  {
    *p1++ = *p2++;
  }
}
~~~

寄存器指针变量：

~~~shell
void try4()
{
  register int *p1, *p2;
  register int i;
  
  for( i = 0;p1 = x, p2 = y;i < SIZE; i++)
    *p1++ = *p2++;
}
~~~

消除计数器：

~~~shell
void try5()
{
  register int *p1, *p2;

  for( p1 = x, p2 = y;p1 < &x[SIZE])
  {
    *p1++ = *p2++;
  }
}
~~~

重新使用计数器是一个比较不错的写法，而消除计数器则是一个更加快速的执行代码。

**结论**:  

1. 使用指针变量将比使用下标产生效率更高的代码。当这个增量是1并且机器具有地址自动增量模型时，这点表现得更为突出。
2. 如果有经过初始化并经过调整的内容来判断循环是否应该终止，就不需要使用一个单独的计数器。
3. 那些必须在运行时求值的表达式诸如`&array[SIZE]`或`array+SIZE`这样的常量表达式往往代价更高。

### 8.1.5 数组和指针

- 指针和数组并不是相等的。

在使用`int a[10]` 和 `int *b`这两个指针值时表达式`*a`是合法而`*b`是非法的；表达式`b++`可以通过编译，但`a++`不行。

### 8.1.6 作为函数参数的数组名

~~~shell
void strcpy(char *buffer, char const *string)
{
  while (*buffer++ = *string++ != '\0');
}
~~~

while语句中的`*string++`表达式取得string所指向的那个字符，并且产生一个副作用，就是修改`string`，使它指向下一个字符。用这种方法修改形参并不会影响调用程序的实参，因为只有传递给函数的那份拷贝进行了修改。

### 8.1.7 声明数组参数

`int strlen(char * string)`和`int strlen(char string[])`这两种声明是相等的，**但是只在当前这个上下文环境中**。

- 使用`char *string`指针声明数组参数更加准确，且数组作为形参不需要传递元素个数，因为函数并不为数组参数分配内存空间，**形参只是一个指针**。

### 8.1.8 初始化

`int vector[5] = {10,20,30,40,50};`是一个标准的数组初始化。

#### 静态和自动初始化

- 数组初始化的方式类似于标量变量的初始化方式---也就是取决于它们的存储类型。
- 存储在静态内存的数组只初始化一次，也就是在程序开执行之前。
- 对于自动变量而言自动变量位于运行时堆栈编译器没办法在程序开始前对它进行初始化。所以自动变量在缺省情况下是未初始化的。

> 当数组的初始化局部于一个函数(或代码块)时，你应该仔细考虑一下，在程序的执行流每次进入该函数(或代码块)时，每次都对数组进行重新初始化是不是值得。如果答案是否定的，就把数组声明为`static`，这样数组的初始化只需在程序开始前执行一次。

### 8.1.9 不完整的初始化

- 初始化值数目大于数组长度(编译时错误)；小于则将未初始化的元素初始化为0，且只允许省略最后几个初始值。

### 8.1.10 自动计算数组长度

`int vector[] = {1,2,3,4,5};`让编译器识别数组大小

### 8.1.11 字符数组的初始化

两种初始化方法：  
1.`char message[] = {'H','e','l','l','o',0};`  
2.`char message[] = "Hello";`

这两种初始化方法是相同的，都是一个字符数组初始化列表，而`char* message = "Hello";`是一个**字符串常量**，即一个指向常量字符串"Hello"的指针。上面两个都是可修改的字符数组。

## 8.2 多维数组

- `int martix[6][10]`在某些上下文环境中，既是6行10列，也是10行6列。

### 8.2.1 存储顺序

`int array[4];`是一个存储三个整型元素的数组  
`int array[4][6];`在上面的基础上将三个整型元素改为三个包含6个元素的数组

- 在C中，多维数组的元素存储顺序按照最右边下标率先变化的原则称为**行主序(row major order)**。比如读取`array[2][4]`往下读取应该是`array[2][5]`后是`array[3][0]`。

### 8.2.2 数组名

- 一维数组名的值是一个指针常量，它的类型是"指向元素类型的指针"
- 多维数组和一维数组为一个区别是多维数组的第一维元素实际上是另一个数组

`int martix[3][10];`这个数组名`matrix`的值是一个指向它第一个元素的指针，所以`matrix`是一个指向一个包含10个整型的数组的指针。

### 8.2.3 下标

`matrix`: 指向包含10个整型元素的数组的指针  
`matrix+1`: 指向包含10个整型元素的数组的指针，但是指向的是matrix的下一行  
`*(matrix + 1)`: 包含10个整型元素的子数组(常量指针)，与`matrix[1]`相等  
`*(matrix + 1) + 5`: 上面的常量指针右移5位  
`*(*(matrix + 1) + 5)`: 上面指针所指向的元素，与`matrix[1][5]`值相等  
上面的式子可以改写为：*(matrix[1] + 5)

### 8.2.4 指向数组的指针

~~~shell
int   vector[10], *vp = vector;
int   matrix[3][10], *mp = matrix;
~~~

第一个声明是合法的，第二个声明是非法的。  
`matrix`不是一个指向整型的数组而是一个指向整型数组的指针。

`int (*p)[10]`是一个合法的指向二维数组的数组指针。因为下标引用的优先级高于间接访问
，所以要给`*p`加上括号。

~~~shell
int *pi = &matrix[0][0];
int *pi = matrix[0];
~~~

上面的两个指针指向二维数组的首地址可以逐个访问整型元素而不是逐行在数组中移动
> 应该避免使用`int  (*p)[] = matrix;`这种没有数组长度的声明，因为没有声明数组长度当执行指针运算时它的值将根据空数组的长度进行调整(与0相乘)

### 8.2.5 作为函数参数的多维数组

如果是二维数组你可以声明为以下的任意一个

~~~shell
void func2(int (*mat)[10]);
void func2(int mat[][10]);
~~~

- 编译器必须知道**第二个**及以后各维的长度才能对各下标进行求值，因此在原型中必须声明这些维的长度，也就是在原数组声明时至少为`int mat[][10]`这种并且在函数形参声明时也写成这样

`void func2(int **mat);`是一个指向整型指针的指针，和一开始说的一样，指针和数组是不同的，和指向整型数组的指针不是一回事。

### 8.2.6 初始化

~~~shell
int matrix[2][3] = {100,101,102,110,111,112};

int two_dim[3][5] = {
  {00,01,02,03,04},
  {00,01,02,03,04},
  {00,01,02,03,04}
};
~~~

上面两种初始化的方法都可以，对于三维以上的数组来说也是类似，和一维数组一样也可以省略尾部的几个初始值。

## 8.3 指针数组

`int  *api[10];`: 下标引用的优先级高于间接访问，在这个表达式中首先执行下标引用。  

使用指针数组的场景：

~~~shell
char const *keyword[] = {
    "do",
    "for",
    "register",
    "return",
    "switch",
    "while",
    NULL 
};
#define N_KEYWORD \
  (sizeof(keyword) / sizeof(keyword[0]))

# 判断参数是否与一个关键字列表中的任何单词匹配，并返回匹配的索引值。
# 如果未找到匹配函数返回-1
#include <string.h>

int lookup_keyword( char const* const desired_word, 
              char const *keyword_table[], int const size)
{
  char const **kwp;
  
  // 对于表中的每个单词 ...
  // for (kwp = keyword_table; kwp < keyword_table + size; kwp++)
  // {
  //   if (strcmp(desired_word, *kwp) == 0)
  //       return kwp - keyword_table;
  // }
  for (kwp = keyword_table; kwp != NULL;kwp++)
  {
    if (strcmp(desired_word, *kwp) == 0)
      return kwp - keyword_table;
  }
  

  // 没有找到
  return -1;
}

~~~

> 使用sizeof()对数组元素个数进行自动计数

## 8.4 总结

1. `sizeof(array)`返回的是整个数组所占用的字节而不是一个指针所占用的字节。
2. &array 和 array 指向的地址相同，但是&array的类型为`int (*)[]`而array的类型为`int*`
3. 其他使用数组名的地方数组名都是指向数组第一个元素的指针
4. `数组地址(类似于&array[1][2]) = 数组基地址 + (行索引 * 每行大小) + (列索引 * 每行大小)`

`地址 = 基地址 + (行索引 * 列数 * 元素大小) + (列索引 * 元素大小)`

假如`int array[4][2]`,int大小为2,array的地址为0x1000，则 &array[1][2] = `0x1000 + (1 * 8) + (2 * 4) == 0x1016`

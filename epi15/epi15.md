# 🎶 输入/输出函数

- ANSI C和早期C相比的最大优点之一就是它在规范里所包含的函数库。每个ANSI编译器必须支持一组规定的函数，并具备规范所要求的接口，而且按照规定的行为工作。

## 15.1 错误报告

`perror`函数以一种简单、统一的方式报告错误。（原型定义于stdio.h）

~~~C
void perror(char const *message);
~~~

> 标准库函数在程序存在错误时在一个外部整型变量`errno`（在errno.h中定义）中保存错误代码后把这个信息传递给用户程序，提示操作失败的准确原因。
>> perror最大的优点就是容易使用。

## 15.2 终止执行

`exit`函数用于终止一个程序的执行。（原型定义于stdlib.h）

~~~C
void exit(int status);
~~~

`status`参数返回给操作系统，用于提示程序是否正常完成。
> 预定义符号EXIT_SUCCESS 和 EXIT_FAILURE 分别提示程序的终止是成功还是失败。
>> 一般执行完`perror`后都会执行`exit`

## 15.3 标准I/O函数库

- 标准I/O函数库是在原先I/O库基础上的实现和扩展，例如为printf创建了不同的版本。且函数库引入了缓冲I/O的概念，提高了绝大多数程序的效率。

> 但是标准函数库是在某台特定类型机器上实现的，在其他不同类型的机器上运行相同的程序会出现无法运行的情况。

- ANSI C函数库中的I/O函数在可移植性和完整性上更加完善。

> ANSI C的一个主要优点就是这些修改是通过**增加不同的函数**方式实现，而不是通过对现存函数进行修改来实现，保证了程序的可移植性。

## 15.4 ANSI I/O概念

- 头文件`<stdio.h>`包含了与ANSI函数库的I/O部分有关的声明。

> 尽管不包含这个头文件也能使用某些I/O函数，但绝大多数函数都需要包含这个头文件。
>
### 15.4.1 流

- ANSI C对I/O的概念进行抽象，所有的I/O操作只是简单的移入/移出字节。这种字节流便称为**流(stream)**。

1. 核心概念：抽象(Abstraction)

- **流的本质**：流是对所有I/O操作的抽象
- **统一接口**：所有的I/O设备都被视为类似的设备。
- **程序视角**：对C程序而言，所有的I/O操作都只是在流上进行字节的移进或移出。
- **细节隐藏**：特定的I/O设备的细节对程序员是隐藏的。

2. 核心机制：缓冲(Buffering)

大多数流是***完全缓冲的(fully buffered)***

- **读取操作**：当进行"读取"时，实际上是从一块较大的缓冲区(buffer)中读取数据。当缓冲区空时，程序才通过设备或文件读取下一块较大的输入数据并重新填充缓冲区。
- **写入操作**："写入"也是先写入到内存中的缓冲区，直到缓冲区写满时，数据才被一次性写入(flush,冲洗或刷新)到设备或文件。
- **效率优势**：这种块状写入和读取操作由于减少了与设备或文件的交互次数，能够实现更快速的I/O。

解决输出延迟

~~~C
printf("something or other");
fflush(stdout); // 立即将缓冲区内容写出
~~~

> 在通常的编程测试中，stdout默认是行缓冲模式。

~~~C
// 没有\n触发自动刷新，会暂停五秒后再执行printf
#include <stdio.h>
#include <unistd.h> // for sleep

int main() {
    // 1. 没有 \n，数据进入缓冲区，但不会自动刷新
    printf("等待 5 秒，你可能看不到我...");
    
    // 2. 暂停执行
    sleep(5); 

    // 3. 补上 \n
    printf("\n我现在出来了。\n"); 
    return 0;
}
~~~

~~~C
// 有\n触发自动刷新，会先执行printf后等待五秒后执行另一个printf
#include <stdio.h>
#include <unistd.h> // for sleep

int main() {
    // 1. 没有 \n，数据进入缓冲区，但不会自动刷新
    printf("等待 5 秒，你可能看不到我...");
    
    // 2. 暂停执行
    sleep(5); 

    // 3. 补上 \n
    printf("\n我现在出来了。\n"); 
    return 0;
}
~~~

> stdin是类似的，都是行缓冲模式。

- 对于输入流来说，只有缓冲区空了，程序才会从外部设备获取新的数据来填充它。
- 对于输出流来说，只有缓冲区满了，缓冲区中的数据才会被写入到外部设备，进行刷新。

#### 一、文本流(Text Stream)

流分为两种，**文本(text)流** 和 **二进制(binary)** 流。文本流的有些特性在不同的系统中可能不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在***MS-DOS***系统中，文本文件约定以一个回车符和一个换行符（或称为行反馈符）结尾。但是***UNIX***系统只使用一个换行符结尾。

- 核心特点：字符翻译

文本流在数据传输中会引入一个**翻译层**，主要针对换行符(`\n`)：

|操作|C程序中的表示|操作系统/文件中实际存储的表示|
|:---:|:---:|:---:|
|写入(`fprintf`,`fputs`)|写入一个换行符(`\n`)|操作系统可能会将其翻译成一个或多个字符序列(例如Windows下的`\r\n`)|
|读取(`fscanf`,`fgets`)|从文件中读取多个字符序列（例如Windows下的`\r\n`）|C运行时库会将这个序列翻译回单个换行符(`\n`)供C程序使用。|

- 优点：保持了跨平台的**文本文件兼容性**。可以在任何系统上打开并正确显示用文本模式创建的文件。
- 缺点：传输的数据量可能与文件中实际存储的字节数**不一致**（因为翻译），且性能略低于二进制流。

#### 二、二进制流(Binary Stream)

二进制流中的字节将完全根据程序编写它们的形式写入到文件或设备中，而且完全根据它们从文件或设备读取的形式读入到程序中。并未做任何改变。

- 核心特点：无翻译

二进制流是**透明的**，它绕过了C运行时库的任何翻译：

|操作|C程序中的表示|操作系统/文件中实际存储的表示|
|:---:|:---:|:---:|
|写入(`fwrite`)|写入N个字节|文件中精确存储N个字节，不做任何修改。|
|读取(`fread`)|读取N个字节|从文件中读取N个原始字节到内存中，不做任何修改。|

- 优点：1.精确性：文件中的字节数与程序处理的字节数总是精准匹配。适用于存储图片、音频、结构体、加密数据等。2.性能：由于没有翻译开销，I/O操作通常更快。
- 缺点：**缺乏可移植性**。如果直接将C结构体写入二进制文件，文件将依赖于机器的字节序(Endianness)和数据类型大小。

### 15.4.2 文件

### 15.4.3 标准I/O常量

## 15.5 流I/O总览
